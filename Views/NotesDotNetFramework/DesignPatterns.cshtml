<div class="main-container">
    <section class="showBullets">
        <div class="container">
            <div class="row">
                <div class="col-sm-10 col-md-8">

                    <h1>@ViewData["Title"]</h1>

                    <div class="container">
                        <div class="row">

                        </div>
                        <br />

                        <div class="row">
                            <h3>SOLID Principal</h3>
                            <div class="container">
                                <p>
                                    Martin's and Feathers' design principles encourage us to create more maintainable, understandable, and flexible software. Consequently, as our applications grow in size, we can reduce their complexity and save ourselves a lot of headaches further down the road!
                                </p>
                                <p>
                                    SOLID principles actually means? Well, it’s just an acronym of the five principles listed as below.
                                    <ul>
                                        <li>S - Single Responsibility Principle (known as SRP)</li>
                                        <li>O - Open/Closed Principle</li>
                                        <li>L - Liskov’s Substitution Principle</li>
                                        <li>I - Interface Segregation Principle</li>
                                        <li>D - Dependency Inversion Principle</li>
                                    </ul>
                                </p>
                                <h4>S — Single Responsibility Principle (known as SRP)</h4>
                                <p>
                                    The name itself suggest that the “class should be having one and only one responsibility”. What does it mean? Well let’s take the class A which does the following operations.
                                    <ul>
                                        <li>Open a database connection</li>
                                        <li>Fetch data from database</li>
                                        <li>Write the data in an external file</li>
                                    </ul>
                                    The issue with this class is that it handles lot of operations. Suppose any of the following change happens in future.
                                    <ul>
                                        <li>New database</li>
                                        <li>Adopt ORM to manage queries on database</li>
                                        <li>Change in the output structure</li>
                                    </ul>
                                    So in all the cases the above class would be changed. Which might affect the implementation of the other two operations as well. So ideally according to SRP there should be three classes each having the single responsibility.
                                </p>
                                <h4>O — Open/Closed Principle</h4>
                                <p>
                                    This principle suggests that “classes should be open for extension but closed for modification”. What is means is that if the class A is written by the developer AA, and if the developer BB wants some modification on that then developer BB should be easily do that by extending class A, but not by modifying class A.
                                </p>
                                <p>
                                    The easy example would be the RecyclerView.Adapter class. Developers can easily extend this class and create their own custom adapter with custom behaviour without modifying the existing RecyclerView.Adapter class.
                                </p>
                                <h4>L — Liskov’s Substitution Principle</h4>
                                <p>
                                    This principle suggests that “parent classes should be easily substituted with their child classes without blowing up the application”. Let’s take following example to understand this.
                                </p>
                                <p>Let’s consider an Animal parent class.</p>
                                <pre><code class="language-csharp">
public class Animal {
    public void makeNoise() {
        System.out.println("I am making noise");
    }
}
                                </code></pre>
                                <p>Now let’s consider the Cat and Dog classes which extends Animal.</p>
                                <pre><code class="language-csharp">
public class Dog extends Animal {
    &#64;Override
    public void makeNoise() {
        System.out.println("bow wow");
    }
}
public class Cat extends Animal {
    &#64;Override
    public void makeNoise() {
        System.out.println("meow meow");
    }
}
                                </code></pre>
                                <p>
                                    Now, wherever in our code we were using Animal class object we must be able to replace it with the Dog or Cat without exploding our code. What do we mean here is the child class should not implement code such that if it is replaced by the parent class then the application will stop running. For ex. if the following class is replace by Animal then our app will crash.
                                </p>
                                <pre><code class="language-csharp">
class DumbDog extends Animal {
    &#64;Override
    public void makeNoise() {
        throw new RuntimeException("I can't make noise");
    }
}
                                </code></pre>
                                <p>
                                    If we take Android example then we should write the custom RecyclerView adapter class in such a way that it still works with RecyclerView. We should not write something which will lead the RecyclerView to misbehave.
                                </p>
                                <h4>I — Interface Segregation Principle</h4>
                                <p>
                                    This principle suggests that "many client specific interfaces are better than one general interface". This is the first principle which is applied on interface, all the above three principles applies on classes. Let’s take following example to understand this principle.
                                </p>
                                <p>In android we have multiple click listeners like OnClickListener as well as OnLongClickListener.</p>
                                <pre><code class="language-csharp">
/**
 * Interface definition for a callback to be invoked when a view is clicked.
 */
public interface OnClickListener {
    /**
     * Called when a view has been clicked.
     *
     * &#64;param v The view that was clicked.
     */
    void onClick(View v);
}/**
 * Interface definition for a callback to be invoked when a view has been clicked and held.
 */
public interface OnLongClickListener {
    /**
     * Called when a view has been clicked and held.
     *
     * &#64;param v The view that was clicked and held.
     *
     * &#64;return true if the callback consumed the long click, false otherwise.
     */
    boolean onLongClick(View v);
}
                                </code></pre>
                                <p>Why do we need two interfaces just for same action with one single tap and another with long press.</p>
                                <p>Why can’t we have following interface.</p>
                                <pre><code class="language-csharp">
public interface MyOnClickListener {
    void onClick(View v);
    boolean onLongClick(View v);
}
                                </code></pre>
                                <p>
                                    If we have this interface then it will force clients to implement onLongClick even if they don’t even care about long press. Which will lead to overhead of unused methods. So having two separate interfaces helps in removing the unused methods. If any client want both behaviours then they can implement both interfaces.
                                </p>
                                <h4>D — Dependency Inversion Principle</h4>
                                <p>
                                    This principle suggest that “classes should depend on abstraction but not on concretion”. What does it mean that we should be having object of interface which helps us to communicate with the concrete classes. What do we gain from this is, we hide the actual implementation of class A from the class B. So if class A changes the class B doesn’t need to care or know about the changes.
                                </p>
                                <p>
                                    In android if we are following MVP pattern then we need to keep reference of Presenter in our View. Now if we keep the Presenter concrete class object in View then it leads to tight coupling. So what we do is we create a interface which abstracts the implementation of presenter and our view class keeps the reference of the PresenterInterface.
                                </p>
                            </div>
                        </div>
                        <br />

                        <div class="row">
                            <h3>Loosely Coupled</h3>
                            <div class="container">
                                <p>
                                    In computing and systems design, a loosely coupled system is one in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components. Subareas include the coupling of classes, interfaces, data, and services. Loose coupling is the opposite of tight coupling.
                                </p>
                                <h4>Methods for decreasing coupling</h4>
                                <p>Loose coupling of interfaces can be enhanced by publishing data in a standard format (such as XML or JSON).</p>
                                <p>
                                    Loose coupling between program components can be enhanced by using standard data types in parameters. Passing customized data types or objects requires both components to have knowledge of the custom data definition.
                                </p>
                                <p>
                                    Loose coupling of services can be enhanced by reducing the information passed into a service to the key data. For example, a service that sends a letter is most reusable when just the customer identifier is passed and the customer address is obtained within the service. This decouples services because services do not need to be called in a specific order (e.g. GetCustomerAddress, SendLetter).
                                </p>
                                <p>
                                    Loose coupling of application integration in business process automation contexts can be increased by following a presentation layer integration model in which automation applications interact with underlying automated applications through the presentation layer or graphical user interface.
                                </p>
                            </div>
                        </div>
                        <br />

                        <div class="row">
                            <h3>Inversion of Control</h3>
                            <div class="container">
                                <p>
                                    Source: <a href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/ioc/inversion-of-control</a>
                                </p>
                                <img src="~/images/InversionOfControl.png" alt="Inversion Of Control Diagram">
                                <p>
                                    IoC is a design principle which recommends the inversion of different kinds of controls in object-oriented design to achieve loose coupling between application classes. In this case, control refers to any additional responsibilities a class has, other than its main responsibility, such as control over the flow of an application, or control over the dependent object creation and binding (Remember SRP - Single Responsibility Principle). If you want to do TDD (Test Driven Development), then you must use the IoC principle, without which TDD is not possible.
                                </p>
                                <p>
                                    Inversion of Control (IoC) is a design principle (although, some people refer to it as a pattern). As the name suggests, it is used to invert different kinds of controls in object-oriented design to achieve loose coupling. Here, controls refer to any additional responsibilities a class has, other than its main responsibility. This include control over the flow of an application, and control over the flow of an object creation or dependent object creation and binding.
                                </p>
                                <p>
                                    IoC is all about inverting the control. To explain this in layman's terms, suppose you drive a car to your work place. This means you control the car. The IoC principle suggests to invert the control, meaning that instead of driving the car yourself, you hire a cab, where another person will drive the car. Thus, this is called inversion of the control - from you to the cab driver. You don't have to drive a car yourself and you can let the driver do the driving so that you can focus on your main work.
                                </p>
                                <p>The IoC principle helps in designing loosely coupled classes which make them testable, maintainable, and extensible.</p>
                                <p>
                                    For ex, in a Main() function that displays data and requests responses from the user, IoC can be applied by having events on GUIs, wherein the framework will handle the flow of a program by using events.
                                </p>
                                <p>
                                    <h4>This is an ex of dependency:</h4>
                                    <pre><code class="language-csharp">
public class A
{
    B b;

    public A()
    {
        b = new B();
    }

    public void Task1() {
        // do something here..
        b.SomeMethod();
        // do something here..
    }

}

public class B {
    public void SomeMethod() {
        //doing something..
    }
}
                                    </code></pre>
                                    In the above example, class A calls b.SomeMethod() to complete its task1. Class A cannot complete its task without class B and so you can say that "Class A is dependent on class B" or "class B is a dependency of class A".
                                </p>
                                <p>
                                    In the object-oriented design approach, classes need to interact with each other in order to complete one or more functionalities of an application, such as in the above example - classes A and B. Class A creates and manages the life time of an object of class B. Essentially, it controls the creation and life time of objects of the dependency class.
                                </p>
                                <p>
                                    The IoC principle suggests to invert the control. This means to delegate the control to another class. In other words, invert the dependency creation control from class A to another class, as shown below.
                                    <pre><code class="language-csharp">
public class A
{
    B b;

    public A()
    {
        b = Factory.GetObjectOfB();
    }

    public void Task1() {
        // do something here..
        b.SomeMethod();
        // do something here..
    }
}

public class Factory
{
    public static B GetObjectOfB()
    {
        return new B();
    }
}
                                    </code></pre>
                                    As you can see above, class A uses Factory class to get an object of class B. Thus, we have inverted the dependent object creation from class A to Factory. Class A no longer creates an object of class B, instead it uses the factory class to get the object of class B.
                                </p>
                                <p>
                                    Another ex, look at this code:
                                    <pre><code class="language-csharp">
public class CustomerBusinessLogic
{
    DataAccess _dataAccess;

    public CustomerBusinessLogic()
    {
        _dataAccess = new DataAccess();
    }

    public string GetCustomerName(int id)
    {
        return _dataAccess.GetCustomerName(id);
    }
}

public class DataAccess
{
    public DataAccess()
    {
    }

    public string GetCustomerName(int id) {
        return "Dummy Customer Name"; // get it from DB in real app
    }
}
                                    </code></pre>
                                    Problems in the above example classes:
                                    <ol>
                                        <li>
                                            CustomerBusinessLogic and DataAccess classes are tightly coupled classes. So, changes in the DataAccess class will lead to changes in the CustomerBusinessLogic class. For example, if we add, remove, or rename any method in the DataAccess class then we need to change the CustomerBusinessLogic class accordingly.
                                        </li>
                                        <li>
                                            Suppose the customer data comes from different databases or web services and, in the future, we may need to create different classes, so this will lead to changes in the CustomerBusinessLogic class.
                                        </li>
                                        <li>
                                            The CustomerBusinessLogic class creates an object of the DataAccess class using the new keyword. There may be multiple classes which use the DataAccess class and create its objects. So, if you change the name of the class, then you need to find all the places in your source code where you created objects of DataAccess and make the changes throughout the code. This is repetitive code for creating objects of the same class and maintaining their dependencies.
                                        </li>
                                        <li>
                                            Because the CustomerBusinessLogic class creates an object of the concrete DataAccess class, it cannot be tested independently (TDD). The DataAccess class cannot be replaced with a mock class.
                                        </li>
                                    </ol>
                                    Fix it by changing it to this code:
                                    <pre><code class="language-csharp">
public class DataAccessFactory
{
    public static DataAccess GetDataAccessObj()
    {
        return new DataAccess();
    }
}
public class CustomerBusinessLogic
{

    public CustomerBusinessLogic()
    {
    }

    public string GetCustomerName(int id)
    {
        DataAccess _dataAccess =  DataAccessFactory.GetDataAccessObj();

        return _dataAccess.GetCustomerName(id);
    }
}
public class DataAccess
{
    public DataAccess()
    {
    }

    public string GetCustomerName(int id) {
        return "Dummy Customer Name"; // get it from DB in real app
    }
}
                                    </code></pre>
                                    As you can see, the CustomerBusinessLogic class uses the DataAccessFactory.GetCustomerDataAccessObj() method to get an object of the DataAccess class instead of creating it using the new keyword. Thus, we have inverted the control of creating an object of a dependent class from the CustomerBusinessLogic class to the DataAccessFactory class.
                                </p>
                            </div>
                        </div>
                        <br />

                        <div class="row">
                            <h3>Dependency Inversion Principle</h3>
                            <div class="container">
                                <p>
                                    Source: <a href="https://www.tutorialsteacher.com/ioc/dependency-inversion-principle">https://www.tutorialsteacher.com/ioc/dependency-inversion-principle</a>
                                </p>
                                <p>The DIP principle also helps in achieving loose coupling between classes. It is highly recommended to use DIP and IoC together in order to achieve loose coupling.</p>
                                <p>DIP suggests that high-level modules should not depend on low level modules. Both should depend on abstraction.</p>
                                <p>The DIP principle was invented by Robert Martin (a.k.a. Uncle Bob). He is a founder of the SOLID principles.</p>
                                <p>
                                    <h4>DIP Definition</h4>
                                    <ol>
                                        <li>High-level modules should not depend on low-level modules. Both should depend on the abstraction.</li>
                                        <li>Abstractions should not depend on details. Details should depend on abstractions.</li>
                                    </ol>
                                </p>
                                <p>
                                    In the above example, we implemented the factory pattern to achieve IoC. But, the CustomerBusinessLogic class uses the concrete DataAccess class. Therefore, it is still tightly coupled, even though we have inverted the dependent object creation to the factory class.
                                </p>
                                <p>Let's use DIP on the CustomerBusinessLogic and DataAccess classes and make them more loosely coupled.</p>
                                <p>
                                    As per the DIP definition, a high-level module should not depend on low-level modules. Both should depend on abstraction. So, first, decide which is the high-level module (class) and the low-level module. A high-level module is a module which depends on other modules. In our example, CustomerBusinessLogic depends on the DataAccess class, so CustomerBusinessLogic is a high-level module and DataAccess is a low-level module. So, as per the first rule of DIP, CustomerBusinessLogic should not depend on the concrete DataAccess class, instead both classes should depend on abstraction.
                                </p>
                                <p>
                                    This would be the new code:
                                    <pre><code class="language-csharp">
public interface ICustomerDataAccess
{
    string GetCustomerName(int id);
}
public class CustomerDataAccess: ICustomerDataAccess
{
    public CustomerDataAccess()
    {
    }

    public string GetCustomerName(int id) {
        return "Dummy Customer Name";
    }
}
public class DataAccessFactory
{
    public static ICustomerDataAccess GetCustomerDataAccessObj()
    {
        return new CustomerDataAccess();
    }
}
public class CustomerBusinessLogic
{
    ICustomerDataAccess _custDataAccess;

    public CustomerBusinessLogic()
    {
        _custDataAccess = DataAccessFactory.GetCustomerDataAccessObj();
    }

    public string GetCustomerName(int id)
    {
        return _custDataAccess.GetCustomerName(id);
    }
}
                                    </code></pre>
                                </p>
                                <p>
                                    We have implemented DIP in our example where a high-level module (CustomerBusinessLogic) and low-level module (CustomerDataAccess) are dependent on an abstraction (ICustomerDataAccess). Also, the abstraction (ICustomerDataAccess) does not depend on details (CustomerDataAccess), but the details depend on the abstraction.
                                </p>
                                <p>
                                    The advantages of implementing DIP in the above example is that the CustomerBusinessLogic and CustomerDataAccess classes are loosely coupled classes because CustomerBusinessLogic does not depend on the concrete DataAccess class, instead it includes a reference of the ICustomerDataAccess interface. So now, we can easily use another class which implements ICustomerDataAccess with a different implementation.
                                </p>
                                <p>
                                    Still, we have not achieved fully loosely coupled classes because the CustomerBusinessLogic class includes a factory class to get the reference of ICustomerDataAccess. This is where the Dependency Injection pattern helps us. In the next chapter, we will learn how to use the Dependency Injection (DI) and the <b>Strategy pattern</b> using the above example.
                                </p>
                            </div>
                        </div>
                        <br />

                        <div class="row">
                            <h3>Dependency Injection</h3>
                            <div class="container">
                                <p>
                                    Source: <a href="https://www.tutorialsteacher.com/ioc/dependency-injection">https://www.tutorialsteacher.com/ioc/dependency-injection</a>
                                </p>
                                <p>Dependency Injection (DI) is a design pattern which implements the IoC principle to invert the creation of dependent objects.</p>
                                <p>
                                    Dependency Injection (DI) is a design pattern used to implement IoC. It allows the creation of dependent objects outside of a class and provides those objects to a class through different ways. Using DI, we move the creation and binding of the dependent objects outside of the class that depends on them.
                                </p>
                                <p>
                                    The Dependency Injection pattern involves 3 types of classes:
                                    <ol>
                                        <li>Client Class: The client class (dependent class) is a class which depends on the service class.</li>
                                        <li>Service Class: The service class (dependency) is a class that provides service to the client class.</li>
                                        <li>Injector Class: The injector class injects the service class object into the client class.</li>
                                    </ol>
                                </p>
                                <p>
                                    The following figure illustrates the relationship between these classes:
                                    <img src="~/images/DependencyInjection_ClassRelationship.png" alt="Dependency Injection Class Relationship">
                                </p>
                                <p>
                                    As you can see, the injector class creates an object of the service class, and injects that object to a client object. In this way, the DI pattern separates the responsibility of creating an object of the service class out of the client class.
                                </p>
                                <p>
                                    The problem with the above example (the last code written) is that we used DataAccessFactory inside the CustomerBusinessLogic class. So, suppose there is another implementation of ICustomerDataAccess and we want to use that new class inside CustomerBusinessLogic. Then, we need to change the source code of the CustomerBusinessLogic class as well. The Dependency injection pattern solves this problem by injecting dependent objects via a <b>constructor</b>, a <b>property</b>, or an <b>interface</b>.
                                </p>
                                <p>
                                    The following figure illustrates the DI pattern implementation for the above example.
                                    <img src="~/images/DependencyInjection_ClassRelationship_example.png" alt="Dependency Injection Class Relationship - Example">
                                </p>
                                <p>
                                    As you see, the CustomerService class becomes the injector class, which sets an object of the service class (CustomerDataAccess) to the client class (CustomerBusinessLogic) either through a <b>constructor</b>, a <b>property</b>, or a <b>method</b> to achieve loose coupling. Let's explore each of these options.
                                </p>
                                <h4>Constructor Injection</h4>
                                <p>As mentioned before, when we provide the dependency through the constructor, this is called a <b>constructor injection</b>.</p>
                                <p>Consider the following example where we have implemented DI using the constructor.</p>
                                <pre><code class="language-csharp">
public class CustomerBusinessLogic
{
    ICustomerDataAccess _dataAccess;

    public CustomerBusinessLogic(ICustomerDataAccess custDataAccess)
    {
        _dataAccess = custDataAccess;
    }

    public CustomerBusinessLogic()
    {
        _dataAccess = new CustomerDataAccess();
    }

    public string ProcessCustomerData(int id)
    {
        return _dataAccess.GetCustomerName(id);
    }
}

public interface ICustomerDataAccess
{
    string GetCustomerName(int id);
}

public class CustomerDataAccess: ICustomerDataAccess
{
    public CustomerDataAccess()
    {
    }

    public string GetCustomerName(int id)
    {
        //get the customer name from the db in real application
        return "Dummy Customer Name";
    }
}
                                </code></pre>
                                <p>In the above example, CustomerBusinessLogic includes the constructor with one parameter of type ICustomerDataAccess. Now, the calling class must inject an object of ICustomerDataAccess.</p>
                                <pre><code class="language-csharp">
public class CustomerService
{
    CustomerBusinessLogic _customerBL;

    public CustomerService()
    {
        _customerBL = new CustomerBusinessLogic(new CustomerDataAccess());
    }

    public string GetCustomerName(int id) {
        return _customerBL.ProcessCustomerData(id);
    }
}
                                </code></pre>
                                <p>
                                    As you can see in the above example, the CustomerService class creates and injects the CustomerDataAccess object into the CustomerBusinessLogic class. Thus, the CustomerBusinessLogic class doesn't need to create an object of CustomerDataAccess using the new keyword or using factory class. The calling class (CustomerService) creates and sets the appropriate DataAccess class to the CustomerBusinessLogic class. In this way, the CustomerBusinessLogic and CustomerDataAccess classes become "more" loosely coupled classes.
                                </p>
                                <h4>Property Injection</h4>
                                <p>In the property injection, the dependency is provided through a public property. Consider the following example.</p>
                                <pre><code class="language-csharp">
public class CustomerBusinessLogic
{
    public CustomerBusinessLogic()
    {
    }

    public string GetCustomerName(int id)
    {
        return DataAccess.GetCustomerName(id);
    }

    public ICustomerDataAccess DataAccess { get; set; }
}

public class CustomerService
{
    CustomerBusinessLogic _customerBL;

    public CustomerService()
    {
        _customerBL = new CustomerBusinessLogic();
        _customerBL.DataAccess = new CustomerDataAccess();
    }

    public string GetCustomerName(int id) {
        return _customerBL.GetCustomerName(id);
    }
}
                                </code></pre>
                                <p>
                                    As you can see above, the CustomerBusinessLogic class includes the public property named DataAccess, where you can set an instance of a class that implements ICustomerDataAccess. So, CustomerService class creates and sets CustomerDataAccess class using this public property.
                                </p>
                                <h4>Method Injection</h4>
                                <p>
                                    In the method injection, dependencies are provided through methods. This method can be a class method or an interface method.
                                </p>
                                <p>The following example demonstrates the method injection using an interface based method.</p>
                                <pre><code class="language-csharp">
interface IDataAccessDependency
{
    void SetDependency(ICustomerDataAccess customerDataAccess);
}

public class CustomerBusinessLogic : IDataAccessDependency
{
    ICustomerDataAccess _dataAccess;

    public CustomerBusinessLogic()
    {
    }

    public string GetCustomerName(int id)
    {
        return _dataAccess.GetCustomerName(id);
    }
        
    public void SetDependency(ICustomerDataAccess customerDataAccess)
    {
        _dataAccess = customerDataAccess;
    }
}

public class CustomerService
{
    CustomerBusinessLogic _customerBL;

    public CustomerService()
    {
        _customerBL = new CustomerBusinessLogic();
        ((IDataAccessDependency)_customerBL).SetDependency(new CustomerDataAccess());
    }

    public string GetCustomerName(int id) {
        return _customerBL.GetCustomerName(id);
    }
}
                                </code></pre>
                                <p>
                                    In the above example, the CustomerBusinessLogic class implements the IDataAccessDependency interface, which includes the SetDependency() method. So, the injector class CustomerService will now use this method to inject the dependent class (CustomerDataAccess) to the client class.
                                </p>
                                <p>Thus, you can use <b>DI</b> and <b>strategy pattern</b> to create loose coupled classes.</p>
                                <p>
                                    So far, we have used several principles and patterns to achieve loosely coupled classes. In professional projects, there are many dependent classes and implementing these patterns is time consuming. Here the <b>IoC Container</b> (aka the <b>DI container</b>) helps us. Learn about the <b>IoC Container</b> in the next chapter.
                                </p>
                                <h4>IoC Container</h4>
                                <p>
                                    The IoC container is a framework used to manage automatic dependency injection throughout the application, so that we as programmers do not need to put more time and effort into it. There are various IoC Containers for .NET, such as Unity, Ninject, StructureMap, Autofac, etc.
                                </p>
                            </div>
                        </div>
                        <br />


                        @*
        <div class="row">
            <h3>Create your first migration</h3>
            <div class="container">
                <ul>
                    <li>PM> add-migration InitialModel</li>
                    <li>InitialModel = Give it a name related to the type of change we’ve made to the Domain model.</li>
                    <li>Under Migrations folder, a new .cs file is created, prefixed with numbers + “_InitialModel.cs”.</li>
                </ul>
            </div>
        </div>
        <br />

        <div class="row">
            <h3>Create your first migration</h3>
            <div class="container">
                <ul>
                    <li>PM> add-migration InitialModel</li>
                    <li>InitialModel = Give it a name related to the type of change we’ve made to the Domain model.</li>
                    <li>Under Migrations folder, a new .cs file is created, prefixed with numbers + “_InitialModel.cs”.</li>
                </ul>
            </div>
        </div>
        <br />

        <div class="row">
            <h3>Create your first migration</h3>
            <div class="container">
                <ul>
                    <li>PM> add-migration InitialModel</li>
                    <li>InitialModel = Give it a name related to the type of change we’ve made to the Domain model.</li>
                    <li>Under Migrations folder, a new .cs file is created, prefixed with numbers + “_InitialModel.cs”.</li>
                </ul>
            </div>
        </div>
        <br />

        <div class="row">
            <h3>Create your first migration</h3>
            <div class="container">
                <ul>
                    <li>PM> add-migration InitialModel</li>
                    <li>InitialModel = Give it a name related to the type of change we’ve made to the Domain model.</li>
                    <li>Under Migrations folder, a new .cs file is created, prefixed with numbers + “_InitialModel.cs”.</li>
                </ul>
            </div>
        </div>
        <br />*@

                    </div>
                </div>
            </div>

        </div>
    </section>
</div>